---
title: JNI 简介
date: 2016-05-14 21:30:15
tags: [Java, 基础]
categories: Android
---

从本章的介绍中可以看出来，Android 的上层使用 Java 语言来进行应用程序开发，但是本地库都是使用 C/C++ 来实现，这中间是需要粘合的，这种粘合方式就是 JNI 。

JNI 是 Java Native Interface 的缩写，它提供了若干的 API 实现了 Java 和其他语言的通信（主要是 C&C++ ）。

在《 Android 技术内幕(系统卷)》这本书里面，有一幅图可以很好的展现这层关系：<!--more-->
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-JNI.png" height="300" alt="Android-JNI"/></div>

这个图可以映射到 Android 系统的框架图去看，可以明显看到：__JNI 是粘合框架层和库层的重要组件__。

## JNI的基础用法

#### 示例
先来看一个 Android 上简单的JNI使用🌰。

先写如下这样一个类：

```java
package com.footprint.littleshell;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

/**
 * Created by liquanmin on 16/5/11.
 */
public class TestActivity extends Activity implements View.OnClickListener {
    protected EditText et;
    protected Button button;

	 static{
		 System.loadLibrary("test_jni");
	 }
    public native String getMessage();

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        super.setContentView(R.layout.activity_test);
        initView();
    }

    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.button) {
            et.setText(getMessage());
        }
    }

    private void initView() {
        et = (EditText) findViewById(R.id.et);
        button = (Button) findViewById(R.id.button);
        button.setOnClickListener(TestActivity.this);
    }
}
```
如代码所示，这个类声明了一个 native 方法`getMessage()`，然后编译这个类（在 IDE 里面可以简单的使用`Build->Rebuild Project`来进行）。

这个类是声明在`com.footprint.littleshell`，我们进入`com`所在目录，执行如下命令：`javah -jni com.footprint.littleshell.TestActivity`，就可在`com`所在目录下面得到如下文件：`com_footprint_littleshell_TestActivity.h`。
>一定要是包所在目录，而不是编译出来的 class 文件所在目录。
>
>另外，在 Mac 下，命令执行可能会出现中文乱码，可以使用如下命令解决：`export JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF-8`。
>
>在 Android Studio 里面，可以通过选择对应的class文件，右击 -> "Android tools" -> "javah"生成头文件；

这个`.h`文件内容如下：

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_footprint_littleshell_TestActivity */

#ifndef _Included_com_footprint_littleshell_TestActivity
#define _Included_com_footprint_littleshell_TestActivity
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_footprint_littleshell_TestActivity
 * Method:    getMessage
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_footprint_littleshell_TestActivity_getMessage
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```
在 Android 上，可以使用 NDK 来完成整个 JNI 的开发：

1. 右击 Module，选择"New" -> "Folder" -> "JNI Folder"。这样就会在对应的 Moudle 中与`java`同级目录处生成`jni`目录；
2. 将刚刚生成的`.h`文件拷贝到这个目录下面；
3. 在项目中的`local.properties`文件中配置 NDK 的位置，比如在我的电脑上，就需要增加如下一行:`ndk.dir=/Users/xxx/Documents/xxxx/Software/NDK/android-ndk-r10d`；

完成以上步骤之后，在`jni`目录下面新建一个`.c`文件实现以上的`.h`文件，名字随意，比如`test_jni.c`：

```java
#include <jni.h>
#include "com_footprint_littleshell_TestActivity.h"

JNIEXPORT jstring JNICALL Java_com_footprint_littleshell_TestActivity_getMessage
  (JNIEnv *env, jobject obj)
{
    return (*env)->NewStringUTF(env, "Hello World! It's JNI");
}
```

>注意：文件不要写成`cpp`文件，否则会发生错误，具体可以见[error: base operand of ‘->’ has non-pointer type ‘JNIEnv’](http://stackoverflow.com/questions/15764948/error-base-operand-of-has-non-pointer-type-jnienv)。

之后，我们在该模块的`build.gradle`中进行 ndk 的配置：

```java
defaultConfig {
	applicationId "com.footprint.littleshell"
	minSdkVersion 14
	targetSdkVersion 22
	versionCode 1
	versionName "1.0"

	ndk{
		moduleName "test_jni"
	}
}
```
如上所示，这里配置 moduleName 为"test_jni"——最后生成的`.so`分享库的名字，实际会在前面加上 lib ，后面加上 .so，即最终生成`libtest_jni.so`库。

<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-NDK.png" height="360" alt="Android-NDK"/></div>

如图，在上面方框的文件夹中就生成了对应的`.so`库，在与`java`同级的目录中建立 jniLibs 目录，把上面方框 lib 目录下面的文件夹全部拷贝过来(实际开发中以支持的CPU架构为标准)，这样，就完成了`.so`库的开发，在 Java 代码里面，加上如下代码即可使用:

```java
static{
	System.loadLibrary("test_jni");
}
```
结果如下：
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/jni-demo.png" height="320" alt="JNI demo"/></div>

>关于使用 Android Studio 进行 NDK 开发，也可以参考[Android Studio中NDK开发](http://www.race604.com/android-studio-with-ndk/)这篇文章。从例子看，还是很方便的。

#### 解释
生成的`.h`函数中有一个方法: `JNIEXPORT jstring JNICALL Java_com_footprint_littleshell_TestActivity_getMessage
  (JNIEnv *, jobject);`。这个方法是怎么来的呢？

首先是方法名：这个名字看着很眼熟：它是在 Java 声明的 native 方法名字前面加上了方法所在类的全限定名，并将包分隔符`.`换成`_`，最后在前面加上`Java_`来表示的，读者可以多写几个函数，就会发现这是一个普遍规律。

传进来的两个参数代表什么呢？

1. `JNIEnv *` 这代表一个 Java 虚拟机(JVM)所运行的环境，从它可以访问到 JVM 内部的各种对象；
2. `jobject` 调用该函数的对象，例子中所指的就是`TestActivity`；

## 原理
本章说明说提到的三本书都有关于 JNI 的介绍。

#### 静态注册
从前面的例子中可以看出，我们在 Java 中调用 native 方法`getMessage()`时，实际是被映射到了`Java_com_footprint_littleshell_TestActivity_getMessage`上，那么这种映射关系是如何建立的呢？

前面描述了`javah`命令生成的 native 函数名称的由来，这其实是一种规范，这种映射关系的建立称为静态映射：在`.h`文件生成时，就按照一定的规则生成本地方法名称，从而JVM也能根据这种规则在 Java 调用 native 函数时，找到对应的本地方法。

这种方式产生的 native 方法名字很长，不便于管理，因此 JNI 还可以进行动态注册——开发者可以任意命名 native 函数名称。

#### 动态注册
静态注册生成的native函数名字冗长，自己去写太麻烦，而如果直接从 class 文件生成，则每一个 class 文件都要执行`javah`命令（虽然可能不是很多），这里提供另外一种选择：动态注册。使用这种技术，我们可以任意命名 native 函数名，手动建立 native 函数到 Java 函数的映射关系。

先来看看如何实现动态注册：大致做法和前面一致，只是不再需要执行`javah`命令生成头文件，在`jni`目录下面，我们只需要建立一个 test_jni.c 文件，其内容如下：

```C
#include <jni.h>
#include <stdio.h>

//注意：这个方法一定要声明在gMethods之前，否则会报找不到方法的错误
JNIEXPORT jstring  JNICALL getMessageNative(JNIEnv *env, jobject obj)
{
    return (*env)->NewStringUTF(env, "Hello World! It's JNI");
}

static JNINativeMethod gMethods[] = {
        {"getMessage",  "()Ljava/lang/String;",  (void*) getMessageNative}
};

JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void *reserved) //这是JNI_OnLoad的声明，必须按照这样的方式声明
{
	//注册时在JNIEnv中实现的，所以必须首先获取它
	JNIEnv* env = NULL;
	
	//从JavaVM获取JNIEnv，一般使用1.4的版本
	if((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_4) != JNI_OK) 
		return -1;

	jclass clazz;
	static const char* const clsName="com/footprint/littleshell/TestActivity";

	//这里可以找到要注册的类，前提是这个类已经加载到java虚拟机中。 这里说明，动态库和有native方法的类之间，没有任何对应关系。
	clazz = (*env)->FindClass(env, clsName); 

	if(clazz == NULL) {
		printf("cannot get class:%s\n", clsName);
		return -1;
	}

	//这里就是关键了，把本地函数和一个java类方法关联起来。不管之前是否关联过，一律把之前的替换掉！
	if((*env)->RegisterNatives(env, clazz, gMethods, sizeof(gMethods)/sizeof(gMethods[0]))!= JNI_OK)  {
		printf("register native method failed!\n");
		return -1;
	}
	
	return JNI_VERSION_1_4; //必须返回版本，否则加载会失败。
}
```

配置好 gradle（参见上面），build 工程，拷贝生成的`.so`文件，运行即可。下面我们来重点解析这个 c 文件的内容。
>PS: 例子内容以及注释来自[Java JNI_OnLoad的妙用](http://blog.csdn.net/imyfriend/article/details/9117917)。

动态注册基于以下内容实现：

1. 当 Java 层通过`System.loadLibrary()`加载完JNI动态库后，紧接着会查找该库中一个叫`JNI_OnLoad()`的函数，如果有，就调用它，因此我们可以在这个方法里面进行一些预备工作，比如：静态注册（也可以手动暴露一个 init 方法出来，在加载完成之后手动调用）
2. Java 函数到 native 函数的映射可以由数据结构`JNINativeMethod`来表示。

`JNINativeMethod`结构：

```C
typedef struct {
   	//Java中native函数的名字，不用携带包的路径。例如“native_init“。
	const char* name;
	//Java函数的签名信息，用字符串表示，是参数类型和返回值类型的组合。
	const char* signature;
	//JNI层对应函数的函数指针，注意它是void*类型。
	void*  fnPtr;
} JNINativeMethod;
```
这个结构的三个字段的含义都已经注释清楚，根据例子我们再解释一下：

1. `const char* name;` 在我们的例子中就是`getMessage`；
2. `const char* signature;` 这个是 Java 函数的签名信息，如果要全面了解，建议读者可以去阅读《Java 虚拟机规范》，因为我们的 class 文件也使用同样的数据结构来描述一个方法，规范中有详细说明；
3. `void*  fnPtr;` 指向本地方法的函数指针，把 fnPtr 换成 native 函数名称就好，这个名字不需要再遵循静态注册的规范；

从这个关系就可以看出是要从 Java 的哪个函数映射到 native 的哪个函数。之后的事情很简单：__通过 JNIEnv 的`RegisterNatives`方法告诉 JVM 虚拟机我要给某个类（通过类名指定）注册哪些函数映射（通过 JNINativeMethod 数组表示）。__

比对示例代码应该很好理解。

## 总结
JNI学习重点：

1. 加载库——两种方法 & 它们的区别；
2. 方法映射——方法定义方式，方法映射方式；
3. 数据类型映射——重点是字符串和数组；
4. 反向调用——C++层调用Java层方法和属性，调用方法包括调用实例方法、静态方法、构造方法、父类方法等；
5. 引用类型和管理——局部引用，全局引用，全局弱引用三种；
6. 异常处理;

这里推荐一个博客系列: [CSDN@xyang0917——JNI](http://blog.csdn.net/xyang81/article/category/2759987)。博客讲述比较全，而且有比较详细的例子，对于入门 & 熟悉JNI有很大的帮助。当然最全面的教程还是在官网: [JNI Interface Functions and Pointers](https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/design.html)。